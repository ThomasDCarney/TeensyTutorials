/*******************************************************************************
 * This is a test script used to cycle through audio files stored on the Prop
 * Shield's flash memory. Used to listen to a larger set of files, see how they
 * sound.
 *
 * GENERAL SETUP:
 * - 1 x Teensy 3.2
 * - 1 x Teensy Prop Shield
 * - 3 x Momentary Push Button
 * - 1 x Speaker
 * - 5V power (to drive speaker)
 *
 * TODO... Expand the list, draw up a circuit diagram for all the things and
 * link here.
 ******************************************************************************/


#define DEBUG


/*******************************************************************************
 * AUDIO DESIGN: Most of this section is generated by the Teensy Audio Design
 * Tool. You could go crazy here and add an input for each audio file, set up
 * fancy fades and effects but again, crazy for testing. You only need one
 * "AudioPlaySerialflahRaw" object for each audio files that may be playing
 * concurrently. If one sound always ends before another begins then one object
 * can just play one after another.
 ******************************************************************************/

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

// GUItool: begin automatically generated code
AudioPlaySerialflashRaw  playFlashRaw;
AudioOutputAnalog        dac;
AudioConnection          patchCord1(playFlashRaw, dac);
// GUItool: end automatically generated code


/*******************************************************************************
 * PROP SHIELD SPECIFIC: Define pins to enable used features.
 ******************************************************************************/

#define ENABLE_AMP_PIN 5
#define ENABLE_FLASH_PIN 6


/*******************************************************************************
 * INPUTS: Specify pins and variables used by attached input hardware.
 ******************************************************************************/

#define BACK_BUTTON_PIN 23
#define REPEAT_BUTTON_PIN 22
#define NEXT_BUTTON_PIN 21

// These are used by the ISRs.
volatile boolean wasBackButtonPressed;
volatile boolean wasRepeatButtonPressed;
volatile boolean wasNextButtonPressed;


/*******************************************************************************
 * AUDIO FILES: Since the propshield only has 8MB of flash memory, you'll only
 * be able to save so many at a time. Nothing fancy here, just add those you
 * want to hear to the array below in the order you wish to hear them.
 ******************************************************************************/

// UNCOMMENT WHICHEVER CATEGORY YOU'RE TESTING, ONE AT A TIME

//#define NUM_TRACKS 15
//char fileNames[NUM_TRACKS][10] {
//    "HUM01.raw",
//    "HUM02.raw",
//    "HUM03.raw",
//    "HUM04.raw",
//    "HUM05.raw",
//    "HUM06.raw",
//    "HUM07.raw",
//    "HUM08.raw",
//    "HUM09.raw",
//    "HUM11.raw",
//    "HUM12.raw",
//    "HUM13.raw",
//    "HUM14.raw",
//    "HUM15.raw",
//    "HUM16.raw"
//};

//#define NUM_TRACKS 7
//char fileNames[NUM_TRACKS][10] {
//    "MLT01.raw",
//    "MLT02.raw",
//    "MLT03.raw",
//    "MLT04.raw",
//    "MLT05.raw",
//    "MLT06.raw",
//    "MLT07.raw"
//};

//#define NUM_TRACKS 6
//char fileNames[NUM_TRACKS][6] {
//    "OFF01.raw",
//    "OFF02.raw",
//    "OFF03.raw",
//    "OFF04.raw",
//    "OFF05.raw",
//    "OFF06.raw"
//};

#define NUM_TRACKS 10
char fileNames[NUM_TRACKS][9] = {
  "ON01.raw",
  "ON02.raw",
  "ON03.raw",
  "ON04.raw",
  "ON05.raw",
  "ON06.raw",
  "ON07.raw",
  "ON08.raw",
  "ON09.raw",
  "ON10.raw"
};

//#define NUM_TRACKS 25
//char fileNames[NUM_TRACKS][10] {
//    "STR01.raw",
//    "STR02.raw",
//    "STR03.raw",
//    "STR04.raw",
//    "STR05.raw",
//    "STR06.raw",
//    "STR07.raw",
//    "STR08.raw",
//    "STR09.raw",
//    "STR10.raw",
//    "STR11.raw",
//    "STR12.raw",
//    "STR13.raw",
//    "STR14.raw",
//    "STR15.raw",
//    "STR16.raw",
//    "STR17.raw",
//    "STR18.raw",
//    "STR19.raw",
//    "STR20.raw",
//    "STR21.raw",
//    "STR22.raw",
//    "STR23.raw",
//    "STR24.raw",
//    "STR25.raw"
//};

//#define NUM_TRACKS 30
//char fileNames[NUM_TRACKS][10] {
//    "STR01.raw",
//    "STR02.raw",
//    "STR03.raw",
//    "STR04.raw",
//    "STR05.raw",
//    "STR06.raw",
//    "STR07.raw",
//    "STR08.raw",
//    "STR09.raw",
//    "STR10.raw",
//    "STR11.raw",
//    "STR12.raw",
//    "STR13.raw",
//    "STR14.raw",
//    "STR15.raw",
//    "STR16.raw",
//    "STR17.raw",
//    "STR18.raw",
//    "STR19.raw",
//    "STR20.raw",
//    "STR21.raw",
//    "STR22.raw",
//    "STR23.raw",
//    "STR24.raw",
//    "STR25.raw",
//    "STR26.raw",
//    "STR27.raw",
//    "STR28.raw",
//    "STR29.raw",
//    "STR30.raw"
//};


// Declare general state variables.
int currentTrack;


void setup() {

    initPropShield();
    initInputs();
    initStateVariables();

#ifdef DEBUG

    Serial.begin(9600);
    while(!Serial) {

        // Just wait until the serial connection kicks in.

    };

#endif

} // end setup


void loop() {

    // Do nothing until a button is pressed.
    if(anyButtonsWaiting()) {

        // Check which button was pressed.
        if(wasBackButtonPressed) {

            playPrevious();
            wasBackButtonPressed = false;

        }else if(wasRepeatButtonPressed) {

            playAgain();
            wasRepeatButtonPressed = false;

        }else if(wasNextButtonPressed) {

            playNext();
            wasNextButtonPressed = false;

        }

#ifdef DEBUG

        Serial.print("Max memory Usage: ");
        Serial.println(AudioMemoryUsageMax());

#endif

    }

} // end loop


/*******************************************************************************
 * Use this method to initialize the prop shield.
 ******************************************************************************/
void initPropShield() {

    // Give the audio some memory but note the max used while cycling through
    // final set. Whatever value is greatest is how much you should set aside
    // using AudioMemory() below so update appropriately.
    AudioMemory(20);

    // Enable the audio amp.
    pinMode(ENABLE_AMP_PIN, OUTPUT);
    digitalWrite(ENABLE_AMP_PIN, HIGH);
    delay(10); // Takes a few ticks to kick in.

    // Turn up the amp's power.
    dac.analogReference(EXTERNAL);

    // Enable the serial flash.
    if (!SerialFlash.begin(ENABLE_FLASH_PIN)) {

#ifdef DEBUG

        // No point proceeding if flash won't start so loop an error.
        while (1) {

            Serial.println ("FLASH not enabled");
            delay (3000);

        }

#endif

    }

} // end initPropShield


/*******************************************************************************
 * Use this method to initialize attached input hardware.
 ******************************************************************************/
void initInputs() {

    // Init back button.
    pinMode(BACK_BUTTON_PIN, INPUT);
    attachInterrupt(digitalPinToInterrupt(BACK_BUTTON_PIN),
        backButtonInterruptRoutine, RISING);

    // Init repeat button.
    pinMode(REPEAT_BUTTON_PIN, INPUT);
    attachInterrupt(digitalPinToInterrupt(REPEAT_BUTTON_PIN),
        repeatButtonInterruptRoutine, RISING);

    // Init next button.
    pinMode(NEXT_BUTTON_PIN, INPUT);
    attachInterrupt(digitalPinToInterrupt(NEXT_BUTTON_PIN),
        nextButtonInterruptRoutine, RISING);

} // end initInputs


/*******************************************************************************
 * Use this method to initialize any general/state variables.
 ******************************************************************************/
void initStateVariables() {

    // No buttons should init pressed.
    wasBackButtonPressed = false;
    wasRepeatButtonPressed = false;
    wasNextButtonPressed = false;

    // Start with the first track (arrays starts at 0).
    currentTrack = 0;

} // end initStateVariables


/*******************************************************************************
 * Use this method to play the previous track.
 ******************************************************************************/
void playPrevious() {

    // Index can't be less than 0;
    if(currentTrack > 0) {

        currentTrack--;

    }

    triggerSound(fileNames[currentTrack]);

} // end playPrevious


/*******************************************************************************
 * Use this method to repeat the current track.
 ******************************************************************************/
void playAgain() {

    triggerSound(fileNames[currentTrack]);

} // end playAgain


/*******************************************************************************
 * Use this method to play the next track.
 ******************************************************************************/
void playNext() {

    // Index shouldn't pass the total number of tracks.
    if(currentTrack < NUM_TRACKS - 1) {

        currentTrack++;

    }

    triggerSound(fileNames[currentTrack]);

} // end playNext

/*******************************************************************************
 * Use this method to play a specific audio file.
 *
 * @param filename - A string and name of the file to play.
 ******************************************************************************/
void triggerSound(const char *filename){

    if(playFlashRaw.isPlaying()) {

        playFlashRaw.stop();

    }

#ifdef DEBUG

    Serial.print("Now playing: ");
    Serial.println(filename);

#endif

    playFlashRaw.play(filename);


} // end triggerSound


/*******************************************************************************
 * ISR for the back button.
 ******************************************************************************/
void backButtonInterruptRoutine() {

    // Only flag if no other buttons are waiting
    if(!anyButtonsWaiting()) {

        wasBackButtonPressed = true;

#ifdef DEBUG

    Serial.println("Back Button Pressed");

#endif

    }


} // end backButtonInterruptRoutine


/*******************************************************************************
 * ISR for the repeat button.
 ******************************************************************************/
void repeatButtonInterruptRoutine() {

    // Only flag if no other buttons are waiting
    if(!anyButtonsWaiting()) {

        wasRepeatButtonPressed = true;

#ifdef DEBUG

        Serial.println("Repeat Button Pressed");

#endif

    }

} // end repeatButtonInterruptRoutine


/*******************************************************************************
 * ISR for the next button.
 ******************************************************************************/
void nextButtonInterruptRoutine() {

    // Only flag if no other buttons are waiting
    if(!anyButtonsWaiting()) {

        wasNextButtonPressed = true;

#ifdef DEBUG

        Serial.println("Next Button Pressed");

#endif

    }

} // end nextButtonInterruptRoutine


/*******************************************************************************
 * Helper method used by input ISRs.
 ******************************************************************************/
boolean anyButtonsWaiting() {

    return wasBackButtonPressed || wasRepeatButtonPressed ||
        wasNextButtonPressed;

} // end anyButtonWaiting
